<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>寻找两个正序数组的中位数</title>
    <meta name="description" content="给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 O(log (m+n)) ">
    <script type="module" >
        /**
         * @param {number[]} nums1
         * @param {number[]} nums2
         * @return {number}
         * 样例1
         * 输入：nums1 = [1,3], nums2 = [2]
         * 输出：2.00000
         * 解释：合并数组 = [1,2,3] ，中位数 2
         * 
         * 样例2
         * 输入：nums1 = [1,2], nums2 = [3,4]
         * 输出：2.50000
         * 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
         * 
         * 提示：
         * nums1.length == m
         * nums2.length == n
         * 0 <= m <= 1000
         * 0 <= n <= 1000
         * 1 <= m + n <= 2000
         * -106 <= nums1[i], nums2[i] <= 106
         */
        var findMedianSortedArrays1 = function(nums1, nums2) {//时间复杂度O(m+n),不满足条件
            let all_len = (nums1.length + nums2.length + 1)/2;//要遍历几个数
            let left_index = Math.floor(all_len);
            let right_index = Math.ceil(all_len);//如果是偶数,left right不一样，否则一样
            let num_left;//存储对应index的值
            let num_right;
            let num1_i = 0;//用于索引nums1 nums2的下标
            let num2_i = 0;
            let index = 0;//用于索引left right的下标
            while(num1_i < nums1.length && num2_i < nums2.length && index < right_index){
                num_left = num_right;
                if(nums1[num1_i] > nums2[num2_i]){
                    num_right = nums2[num2_i];
                    num2_i ++;
                }else{
                    num_right = nums1[num1_i];
                    num1_i ++;
                }
                index ++;
            }
            while(num1_i < nums1.length && index < right_index){
                num_left = num_right;
                num_right = nums1[num1_i ++];
                index ++;
            }
            while(num2_i < nums2.length && index < right_index){
                num_left = num_right;
                num_right = nums2[num2_i ++];
                index ++;
            }
            if(left_index == right_index){
                return num_right;
            }else{
                return (num_left + num_right)/2;
            }
        };
        var findMedianSortedArrays2 = function(nums1, nums2) {
            //可以先算出中位数是第几个k
            //每次从两个数组一共取k个，也就是分别取k/2个，然后比对对应位置的元素。
            //极端情况下要么k小个数全在一个数组，要么对半在一个数组，因此假设比对nums1[k/2]和nums2[k/2]
            //如果nums1[k/2]>nums2[k/2]，就意味着nums1[k/2]>nums1的前k/2-1+nums2的k/2个,即k-1个
            //那么nums2[k/2]一定不是第k大的元素
        };
        var findMedianSortedArrays3 = function(nums1, nums2) {
            //计算出中位数时第k个
            //划分两个数组中更小的数组，划分方式从nu

        };

        console.log(findMedianSortedArrays1([1,3],[2]));
        console.log(findMedianSortedArrays1([1,2],[3,4]));

        console.log(findMedianSortedArrays2([1,3],[2]));
        console.log(findMedianSortedArrays2([1,2],[3,4]));
    </script>
</head>
<body>
    
</body>
</html>